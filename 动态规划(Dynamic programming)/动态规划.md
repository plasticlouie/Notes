# 动态规划(Dynamic programming)

## 引例：凑零钱问题

**问题描述：**
有面值为1、3、5元的硬币，如何用最少的硬币凑出11元？
（该问题引用自博客https://www.cnblogs.com/skydreamteam/p/3652971.html）

**问题分析：**
1. 暴力求解：
```
总额          组合          最少硬币数
0              -                 0
1              1                 1
2              11                2
3             111, 3             1
4            1111, 13            2
5           11111, 113, 5        1
6       111111, 1113, 33, 15     2
```
 暴力求解法列出每个总额下的所有组合方式，从中选出硬币数最少的方案。观察总额为6的组合，当最后一枚硬币选3时，有两种方案111|3和3|3，对应总额为3时的两种组合111、3，也就是当最后一枚硬币选3时，还剩3元，只要在总额为3的组合中选取一种最优的，就可以得到在最后一枚硬币选3的情况下，组合出6元的最优解。如果事先记录下凑出总额为3的最优解，那么可以直接得到最后一枚硬币选3的情况下，组合出6元的最优解。
&nbsp;

把问题泛化，设凑出总额为x需要的最少硬币数量为f(x)
&nbsp;

凑11元有很多种方法，假设最后使用的一枚硬币面值为k元，则使用的最少硬币数量为f(11-k)+1。本例中k可以取1、3、5，只要计算出f(11-1)+1、f(11-3)+1、f(11-5)+1，然后在里面取出最小的，就得到了凑11元所需的最少硬币数量。可以归纳出以下公式：
```
f(x) = min{ f(x-1), f(x-3), f(x-5) } + 1
```
所以要计算出f(11)，需要先计算f(10)、f(8)、f(6)，依此类推。可以写出如下Python代码
```
def f(x):
    if x<0:
        return 99999

    if x<=5:
        table = [0,1,2,1,2,1]
        return table[x]

    return min(f(x-1), f(x-3), f(x-5)) + 1
```

## 动态规划
动态规划面对的是多阶段决策问题，每个阶段的决策依赖于之前阶段的状态。动态规划中有三个关键词：阶段、状态、状态转移方程
&nbsp;

**阶段：**
把大问题分解为一个个相互联系的阶段，按照一定次序求解。比如上述问题，阶段就是硬币总额，把硬币总额为11按照一个个子阶段求解
&nbsp;

**状态：**
状态是问题中涉及的关键变量，当前状态依赖于之前的状态。比如上述问题中状态就是最少硬币数量，f(11)依赖于f(10)、f(8)、f(6)
&nbsp;

**状态转移方程：**
当前状态是如何从之前状态转移的，状态转移方程是动态规划的核心。上述问题的状态转移方程为：```f(x) = min{ f(x-1), f(x-3), f(x-5) } + 1```

## 动态规划（基于《算法导论》）
（引用自博客https://www.cnblogs.com/skydreamteam/p/3652971.html）
&nbsp;

**最优子结构：**
问题的最优解包含了子问题的最优解。比如硬币问题中，f(11)包含的子问题f(10)、f(8)、f(6)也是最优解
&nbsp;

**子问题重叠：**
子问题之间可能有重复。比如硬币问题中f(11)会分解出f(8)和f(6)，f(8)分解两次也会得到f(6)。动态规划通过自底向上避免重复计算（直接采用递归会有重复计算的问题）。
&nbsp;

**自底向上：**
从底层问题向上推导。比如硬币问题中，可以从1开始向上推导至11，不会有重复计算，但采用递归从顶向下存在重复计算（因为子问题重叠）

## 例二：斐波那契数列
```
1, 2, 3, 5, 8, 13, 21 ...
```
当前项等于前两项之和。

第n个数用f(n)表示

**阶段：**
把第n个数分解为n-1和n-2个数

**状态：**
第n个阶段的数字```f(n)```

**状态转移方程：**```f(n) = f(n-1) + f(n-2)```

可写出如下Python代码

递归写法：
```
def f(x):
    if x<= 0:
        return 0
    if x==1 or x==2:
        return x
    return f(x-1) + f(x-2)
```

非递归写法：
```
def f(x):
    if x==1 or x==2:
        return x
    f1, f2 = 1, 2
    for i in range(x-2):
        f3 = f1 + f2
        f1 = f2
        f2 = f3
    return f3
```

递归写法（自顶向下）存在大量重复计算，非递归写法（自底向上）没有重复计算。

## 例三：最短路径问题
```
  /   B1 --- C1 --- D1  \
A --  B2 ... .. ..... -- E
  \   B3 --- Cn --- Dm  /
```
如图，起点为A，终点为D，图中间的相邻层全连接（比如B层的每个节点都和C层的每个节点相连），连接的距离用```d(B1,C2)```的形式来表示，求A到E的最短路径长度。
&nbsp;

暴力求解可以遍历所有A到E的路径求出最短的路径。

使用动态规划，以```f(A,C1)```这种形式表示```A```到```C1```的最短距离

**阶段：**
到达不同的层

**状态：**```A```到达每一层的节点的最短距离

**状态转移函数：**```A```到当前层的某个节点的最短路径为```A```到上一层的最短路径加上上一层到当前层的路径，首先算出```A```到```B```层每个节点的最短路径：
```
f(A,B1) = d(A,B1)
f(A,B2) = d(A,B2)
f(A,B3) = d(A,B3)
```

状态转移函数以```C```层 为例：
```
f(A,C1) = min{ f(A,B1)+d(B1,C1), f(A,B2)+d(B2,C1), f(A,B3)+d(B3,C1) }
f(A,C2) = min{ f(A,B1)+d(B1,C2), f(A,B2)+d(B2,C2), f(A,B3)+d(B3,C2) }
...
f(A,Cn) = min{ f(A,B1)+d(B1,Cn), f(A,B2)+d(B2,Cn), f(A,B3)+d(B3,Cn) }
```
从而求出```A```到```C```层任意一个节点的最短路径，依此类推。

注：把每一层作为每一个阶段，最终目标是到达```E```，那么就从最前面的阶段开始**向后递推**（自底向上）。如果从```E```开始**向前递推**（使用递推），就会存在重复计算的问题。
